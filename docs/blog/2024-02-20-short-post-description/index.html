<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brenda Cruz">
<meta name="dcterms.date" content="2024-05-06">
<meta name="description" content="A deep dive into radiomics and machine learning models">

<title>Brenda Cruz - Medical imaging enters a new era with cutting-edge Machine learning techniques for Detection of Breast Cancer Molecular Subtypes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style>

      .quarto-title-block .quarto-title-banner {
        background: images/banner.jpeg;
      }
</style>


</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Brenda Cruz</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About Me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">My Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/bscruz"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<div class="featured-screen">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/radiomicspic-02.jpeg" class="img-fluid quarto-figure quarto-figure-center figure-img" style="theme.scss"></p>
</figure>
</div>
</div>
<p><strong>UWP 104 Science</strong></p>
<p><strong>By Brenda Cruz</strong></p>
<p><br>
</p>
<p>Radiomics, a new field studying medical imaging for detection of breast cancer has emerged!&nbsp;</p>
<p>By studying imaging features, researchers can accurately predict breast cancer molecular subtypes using MRI or mammographies. Mammography screenings are given yearly to women after 45 years old who are at an average risk of obtaining breast cancer. They are like Jane, a 48 year old mother of 3, who’s own mother dealt with complications during her breast cancer journey at 40 years old. A doctor decided to start Jane with her bi-yearly mammography screening, after taking into account her family history.&nbsp;</p>
<p>Jane, like many other women, found reassurance in her bi-yearly mammography screening, which provides the earliest signs of breast cancer detection.&nbsp; With the&nbsp; mammography, radiologists look for early signs of breast cancer by analyzing the distortions, calcifications, and masses to help detect certain molecular subtypes of cancer. The 4 molecular subtypes of breast cancers are luminal A, luminal B, HER2- positive, and triple negative.&nbsp; With the rise of technology, machine learning programs are being used to assist radiologists in the detection of cancer molecular subtypes. Jane’s doctor informed her about the new machine learning models being utilized on her mammography screen to identify the molecular subtype. This method will replace the need for the invasive tru-cut biopsy procedure typically used for obtaining tissue specimens in IHC treatment. Additionally,&nbsp; This technique may provide inconclusive results due to the undersampling of the tumor tissue or inadequate biopsy. Using the advancements in technology Jane’s doctor was able to&nbsp; confirm the presence of luminal A cancer subtype.&nbsp; However, with radiomics being a new form of technology, women much like Jane are skeptical on the use of machine learning to detect molecular subtypes of cancer.</p>
<p>While Radiomics may be a new form of technology, machine learning programs have been implemented for breast cancer detection for quite some time already.&nbsp; There are different types of&nbsp; machine learning programs used for molecular cancer subtypes, and Minxiang Wu and his team&nbsp; at the Department of Biomedical Engineering in the Netherlands have concluded that the decision tree model is the preferred method by training the model with the BI-RADS manual.<img src="https://lh7-us.googleusercontent.com/DSVs57Q0RFYboz2JKf5fIwm7RFTPzDT_ZbbzDAEPjtav6QG0rPTA0e-UjgPCMVuVgv3rxL12PFLRxD9hYI4nqyu1OtYOon8EngGpxM53sHwN9_nq1spCea6CNaBKB8W5lZtpLo-wkFwlCKP-1GScs98.png" class="img-fluid" alt="Figure 1"></p>
<p>The BI- RADS manual provides the standardized breast imaging terminology, report organization, assessment, structure, and a classification system for mammography or MRI of the breast. This manual most likely helped radiologists in the 1990s detect Jane’s mother’s breast cancer.</p>
<p>With advancements in technology researchers&nbsp; have used this&nbsp; manual&nbsp; to train machine learning programs to detect molecular subtypes. The decision tree uses 7 features from the BI-RADs manual to classify the molecular subtypes by defining the important features in the subtypes. The decision tree categorizes the different molecular subtypes depending on the by masses margin, and calcification, mass margin, breast-feeding&nbsp; The radiologists uss&nbsp; the output of the decision tree model as a reference while examining&nbsp; the MRI.&nbsp; The scientists Minxiang were able to create a decision tree as shown in figure 1. <img src="https://lh7-us.googleusercontent.com/pHh_-yzyKw3Ki0JYSA0X6yHXBdm4xDWcMs0x4ZM_Hl1n-7nN0qrxm7qBmC9Y9XE9YPP58pR_CYF6kSdrbkEfCzRNK3TvX9S4iYaz_QVhF1ZdyxN8kU3CrbSDH1wITgbx5sOIzeJB_svf-GnW9BMA5Ic.png" class="img-fluid">Then, the radiologists use their own feature extraction skills to confirm the presence for Luminal A. For example, in the case of Jane, her radiologist was able to detect the presence of luminal A because the decision tree’s output identified the likelihood she will have luminal A. due to&nbsp; her breast feeding history. Using the the decision tree, her radiologists was able to predict her molecular subtype being LUminal A rather than LUminal B subtype because one rule set in the decision tree to detect luminal A and luminal B is woman who have LUminal B have less of a history of breastfeeding. With other rule sets, the decision tree and her radiologists&nbsp; were able to further confirm these analyses.&nbsp;</p>
<p>However Jane was still not convinced by her diagnosis, she worried that if the radiologists confirmed the wrong subtype it would malinform her treatment plan. Molecular subtype is taken into account because a cancer fueled by specific hormones or other proteins may have better outcomes when treated with targeted options.The molecular subtypes of breast cancer are closely related to the treatment and prognosis of patients so jts important e confirm your molecular subtype.&nbsp; Taking into account Jane’s worries her doctor prescribed her with an MRI to further confirm results.&nbsp;</p>
<p><br>
<br>
<br>
<br>
<img src="https://lh7-us.googleusercontent.com/nKqiaz5MT2o2Rn73syD5CPI5uxkP3vicXAABFp6NIGHe6Vk5RIasb_9sYQHsrDTvmJRIkoEkLHwa62GGERd0vdiTQyakAxiM7CFwlqoCUJOKpJibi_Y6YVk6dgPpVzh1hQdRXp1vFaf2-A8hcoUnmlc.png" class="img-fluid"></p>
<p>Usually a second screening is required for clarity. MRI and mammography&nbsp; are oftentimes used together to visualize breast cancer in different ways to provide the most information to the radiologists. With an MRI, radiomics can be used to accurately predict the molecular subtype. Radiomics uses Dynamic contrast enhanced magnetic resonance imaging (DCE-MRI). DCE-MRI enables the quantitative assessment of tumor status by evaluating pattern recognition algorithms and provides features such as tumor size, shape intensity and texture for tumor characterization.&nbsp;</p>
<p>With radiomics the intratumoral subregions are created to distinguish between multiple&nbsp; molecular subtypes by dividing the whole tumor into 3 subregions on the basis of the changes in pixel intensity at different imaging stages. In figure 3,&nbsp; the color changes and becomes more intense depending on the values of time to peak. For instance, in medical imaging, researchers such as Yue and his team are interested in calculating the number of pixels representing a tumor or a specific anatomical structure.<img src="https://lh7-us.googleusercontent.com/WTb6FKQ5DSxxW1JQYQKUNULNkWtG-d3TY8zEVj5HbQCrpSzqSvZW3DrNZfVVc0PXW2TvOyTkQWE_ZLohEfzais27f-B1EpFPY46AvMDZX0EmcpxRCWqVBsoDpAYH65epURjzlBe9qjlHOsqmmQWKqhM.png" class="img-fluid"></p>
<p>So, “describing time to peak and calculating pixels” could involve analyzing an image to determine how long it takes for a certain intensity level to reach its maximum, and then quantifying the number of pixels associated with that feature</p>
<p>Breast cancer is a heterogeneous disease with different morphological and biological characteristics thus different biological processes. With radiomics we can extract features from images to quantitative textual analysis allowing researchers to infer certain biological processes are connected with certain molecular subtypes.&nbsp;</p>
<p>Figure 3. is a breast imaging MRI scan with radiomics application. Figure 3 shows the tumors partitioned by time to peak calculations, with the red, green, and blue colors representing early, moderate, and late Time to peak. Luminal A tumor has higher mean intensity values, which is seen here in the pronounced color of red in the second image.Texture features reflected the difference in the heterogeneity between subtypes Shuqian Feng and dhis team use images such as these to develop classifier models to predict breast cancer luminal subtypes. In the future radiomics applications can be used for molecular classification as a non-invasive, cost and time-effective alternative method, or as an auxiliary tool prior to biopsy to target the most heterogeneous part of the tumor.</p>
<p>However, using time to peak calculation for radiomics&nbsp; is time consuming, and JAne wanted her&nbsp; diagnosis to be quick and accurate so she asked her doctor about the quickest method.&nbsp;</p>
<p>Thankfully, her doctor had just read that Yue and his team back in the Netherlands managed to use&nbsp; automatic segmentation techniques, a form of machine learning to facilitate the RAPID and consistent delineation of lesions using MRI. &nbsp;Her doctor can plan&nbsp; to rapidly work on her analysis of molecular subtype. Jane was happy to hear this for a disease like cancer, every second counts! The faster she can start an effective treatment plan the better.&nbsp;</p>
<p>Radiologists&nbsp; proceed with further analysis of the MRI images, using the random forest algorithms to assist them in the detection of molecular subtypes by helping them autosegmental regions of the tumor. Remember, the decision tree models used to assist radiologists in earlier applications of machine learning programs, well those same decision models can be implemented in radiomics.&nbsp; Decision tree models are a great use of an adaptive test&nbsp; where the outcome of previous tests influence the next performance test. This same idea applies to the random forest tree algorithm which is made up of smaller decision tree models..&nbsp; The randomness allows for the best image feature to be extracted from a random subset of features to include a wide diversity of the model, by also enabling faster results of texture analysis, thereby enhancing the assistive capabilities for radiologists.&nbsp; Automated processing by AI computational tools is a more efficient detection approach to measure the volume and the size of a tumor within a reasonable amount of time. It has great reference significance for guiding the clinical development of follow-up treatment plans and avoiding inaccurate measurement incurred by some inexperienced radiologists.</p>
<p>Jane’s radiologist was able to use radiomics with machine learning programs to make an accurate prediction of the Luminal A molecular subtype. Janes is now&nbsp; confident in&nbsp; results and will be starting treatment soon. She is thankful her doctors heard her worries and were able to walk her through the process.&nbsp;</p>
<p>Here we are with the patient, Jane as she follows up on her treatment, she has a few words she would like to add. “I was worried this new technology would solely dictate my diagnosis without context on the reasoning behind its prediction, but now that I understand radiologists use radiomics and machine learning programs as a tool to make precise predictions, I can feel confident this is the best way for me to obtain accurate and quick results.”&nbsp;</p>
<p><br>
<br>
</p>
<p><br>
</p>



<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-cruz2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Cruz, Brenda. 2024. <span>“Medical Imaging Enters a New Era with
Cutting-Edge Machine Learning Techniques for Detection of Breast Cancer
Molecular Subtypes.”</span> May 6, 2024.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="spcanelon/silvia" issue-term="title" theme="boxy-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>